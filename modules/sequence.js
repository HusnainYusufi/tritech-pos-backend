'use strict';

const { getTenantModel } = require('./tenantModels');

function Counter(conn) {
  if (conn.models.__Counters) return conn.models.__Counters;
  const schema = new conn.base.Schema({
    key: { 
      type: String, 
      required: true,
      trim: true,
      validate: {
        validator: function(v) {
          return v != null && v.trim() !== '';
        },
        message: 'key cannot be null or empty'
      }
    },   // e.g. 'sku'
    seq: { type: Number, default: 0 }
  }, { 
    collection: '__counters', 
    timestamps: false,
    strict: true  // Only save fields defined in schema
  });
  
  // Create sparse unique index on key field
  // Sparse allows multiple documents with MISSING key (from sku.js model)
  // But does NOT allow multiple documents with key: null (null is treated as a value)
  schema.index({ key: 1 }, { unique: true, sparse: true });
  
  return conn.model('__Counters', schema);
}

/** Atomically allocate a block of sequence numbers for a key */
async function allocateSequence(conn, key, count = 1) {
  // Validate key is provided
  if (!key || typeof key !== 'string' || key.trim() === '') {
    throw new Error('key is required and must be a non-empty string');
  }

  const doc = await Counter(conn).findOneAndUpdate(
    { key: String(key).trim() },
    { 
      $inc: { seq: count }
      // Note: _id is auto-generated by MongoDB, we don't need to unset it
      // The key field is what matters for this model
    },
    { new: true, upsert: true }
  ).lean();
  const end = doc.seq;
  const start = end - count + 1;
  return { start, end };
}

module.exports = { allocateSequence };
